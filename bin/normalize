import util from "util";
import fs from "fs";
import path from "path";
import Normalizer from "../lib/Normalizer.js";
import {argv} from "yargs";

function usage() {
    console.log(`
normalizer [-q] [-m] [-a] [-n <norm--definition-file>] [-r <module>] -e <expression> <source-data>
    
    <source-data> = (-j <json-file> | <json-text> | stdin)

    a - data is an array. Each element will be tested separately
    e - the expression to execute on each test
    j - the JSON file to test
    n - the .norm file from which to load definitions
    q - turn on quiet mode
    r - load a node module. All exports will be exposed as functions to the script

`);
}

function prettify(object) {
    const options = {depth: Infinity, colors: true};

    return util.inspect(object, options);
}

function say(message="") {
    if (quiet === false) {
        console.log(message);
    }
}

function main(module) {
    // creator interpreter
    const normalizer = new Normalizer();

    // load type creators from module
    if (module !== null) {
        for (const name in module) {
            normalizer.typeCreators[name] = module[name];
        }
    }

    if (process.stdin.isTTY) {
        // get data
        if ("j" in argv === false && argv._.length === 0) {
            console.error("Must specify data with -j, JSON text, or from STDIN");
            usage();
            process.exit(1);
        }

        const dataSource = ("j" in argv)
            ? fs.readFileSync(path.resolve(argv.j))
            : argv._[0];

        transform(normalizer, JSON.parse(dataSource));
    }
    else {
        let dataSource = "";

        process.stdin.on("data", chunk => {
            dataSource += chunk;
        });

        process.stdin.on("end", () => {
            transform(normalizer, JSON.parse(dataSource));
        });
    }
}

function transform(normalizer, structures) {
    // make sure data is an array
    if ("a" in argv) {
        // if we said it was an array, but it isn't, then treat the data as if -a hadn't been specified
        if (Array.isArray(structures) === false) {
            structures = [structures];
        }
    }
    else {
        structures = [structures];
    }

    // execute norm file and/or user-entered source
    if ("e" in argv === false) {
        console.error("Must have -e option");
        usage();
        process.exit(1);
    }

    // load in any definitions
    if ("n" in argv) {
        const source = fs.readFileSync(path.resolve(argv.n), "utf-8");

        normalizer.addDefinitionsFromSource(source);
    }

    let success = true;

    for (const structure of structures) {
        const result = normalizer.run(argv.e, structure);

        // process result
        if (result !== undefined) {
            // always display result
            console.log(prettify(result));
        }
        else {
            success = false;

            say(`Data: ${prettify(structure)}`);
            say("Messages:");

            for (const message of normalizer.messages) {
                say(`  ${message.level}: ${message.message}`);
            }
        }

        say();
    }

    process.exit(success ? 0 : 1);
}


const quiet = "q" in argv;

if ("r" in argv) {
    import(path.resolve(argv.r)).then(main)
}
else {
    main(null);
}
